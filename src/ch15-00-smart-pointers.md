# 智能指針

> [ch15-00-smart-pointers.md](https://github.com/rust-lang/book/blob/master/second-edition/src/ch15-00-smart-pointers.md)
> <br>
> commit d06a6a181fd61704cbf7feb55bc61d518c6469f9

**指針** （*pointer*）是一個常見的編程概念，它代表一個指向儲存其他數據的位置。第四章學習了 Rust 的引用；他們是一類很平常的指針，以 `&` 符號為標誌並借用了他們所指向的值。**智能指針**（*smart pointers*）是一類數據結構，他們的表現類似指針，但是也擁有額外的元數據和功能，比如說引用計數。智能指針模式起源於 C++。在 Rust 中，普通引用和智能指針的一個額外的區別是引用是一類只借用數據的指針；相反大部分情況，智能指針 **擁有** 他們指向的數據。

本書中已經出現過一些智能指針，雖然當時我們並不這麼稱呼他們。例如在某種意義上說，第八章的 `String` 和 `Vec<T>` 都是智能指針。他們擁有一些數據並允許你修改他們，並帶有元數據（比如他們的容量）和額外的功能或保證（`String` 的數據總是有效的 UTF-8 編碼）。智能指針區別於常規結構體的顯著特性在於他們實現了 `Deref` 和 `Drop` trait，而本章會討論這些 trait 以及為什麼對於智能指針來說他們很重要。

考慮到智能指針是一個在 Rust 經常被使用的通用設計模式，本章並不會覆蓋所有現存的智能指針。很多庫都有自己的智能指針而你也可以編寫屬於你自己的。這裡將會講到的是來自標準庫中最常用的一些：

* `Box<T>`，用於在堆上分配值
* `Rc<T>`，一個引用計數類型，其數據可以有多個所有者
* `RefCell<T>`，其本身並不是智能指針，不過它管理智能指針 `Ref` 和 `RefMut` 的訪問，在運行時而不是在編譯時執行借用規則。

同時我們還將涉及：

* **內部可變性**（*interior mutability*）模式，當一個不可變類型暴露出改變其內部值的 API，這時借用規則適用於運行時而不是編譯時。
* 引用循環，它如何會洩露內存，以及如何避免他們

讓我們開始吧！