## `Rc<T>` 引用計數智能指針

> [ch15-04-rc.md](https://github.com/rust-lang/book/blob/master/second-edition/src/ch15-04-rc.md)
> <br>
> commit 3f2a1bd8dbb19cc48b210fc4fb35c305c8d81b56

大部分情況下所有權是非常明確的：可以準確的知道哪個變數擁有某個值。然而並不總是如此；有時確實可能需要多個所有者。為此，Rust 有一個叫做`Rc<T>`的類型。它的名字是**引用計數**（*reference counting*）的縮寫。引用計數意味著它記錄一個值引用的數量來知曉這個值是否仍在被使用。如果這個值有零個引用，就知道可以在沒有有效引用的前提下清理這個值。

根據現實生活場景來想像的話，它就像一個客廳的電視。當一個人進來看電視時，他打開電視。其他人也會進來看電視。當最後一個人離開房間時，他關掉電視因為它不再被使用了。如果某人在其他人還在看的時候關掉了電視，正在看電視人肯定會抓狂的！

`Rc<T>`用於當我們希望在堆上分配一些內存供程序的多個部分讀取，而且無法在編譯時確定程序的那一部分會最後結束使用它。如果我們知道的話那麼常規的所有權規則會在編譯時強制起作用。

注意`Rc<T>`只能用於單線程場景；下一章並發會涉及到如何在多線程程序中進行引用計數。如果嘗試在多線程中使用`Rc<T>`則會得到一個編譯錯誤。

### 使用`Rc<T>`分享數據

讓我們回到列表 15-5 中的 cons list 例子。在列表 15-11 中嘗試使用`Box<T>`定義的`List`。首先創建了一個包含 5 接著是 10 的列表實例。之後我們想要創建另外兩個列表：一個以 3 開始並後接第一個包含 5 和 10 的列表，另一個以 4 開始其後**也**是第一個列表。換句話說，我們希望這兩個列表共享第三個列表的所有權，概念上類似於圖 15-10：

<img alt="Two lists that share ownership of a third list" src="img/trpl15-03.svg" class="center" />

<span class="caption">Figure 15-10: Two lists, `b` and `c`, sharing ownership
of a third list, `a`</span>

嘗試使用`Box<T>`定義的`List`並不能工作，如列表 15-11 所示：

<span class="filename">Filename: src/main.rs</span>

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let a = Cons(5,
        Box::new(Cons(10,
            Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
```

<span class="caption">Listing 15-11: Having two lists using `Box<T>` that try
to share ownership of a third list won't work</span>

編譯會得出如下錯誤：

```
error[E0382]: use of moved value: `a`
  --> src/main.rs:13:30
   |
12 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
13 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move
   |
   = note: move occurs because `a` has type `List`, which does not
   implement the `Copy` trait
```

`Cons`成員擁有其儲存的數據，所以當創建`b`列表時將`a`的所有權移動到了`b`。接著當再次嘗使用`a`創建`c`時，這不被允許因為`a`的所有權已經被移動。

相反可以改變`Cons`的定義來存放一個引用，不過接著必須指定生命週期參數，而且在構造列表時，也必須使列表中的每一個元素都至少與列表本身存在的一樣久。否則借用檢查器甚至都不會允許我們編譯代碼。

如列表 15-12 所示，可以將`List`的定義從`Box<T>`改為`Rc<T>`：

<span class="filename">Filename: src/main.rs</span>

```rust
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, a.clone());
    let c = Cons(4, a.clone());
}
```

<span class="caption">Listing 15-12: A definition of `List` that uses
`Rc<T>`</span>

注意必須為`Rc`增加`use`語句因為它不在 prelude 中。在`main`中創建了存放 5 和 10 的列表並將其存放在一個叫做`a`的新的`Rc`中。接著當創建`b`和`c`時，我們對`a`調用了`clone`方法。

### 克隆`Rc<T>`會增加引用計數

之前我們見過`clone`方法，當時使用它來創建某些數據的完整拷貝。但是對於`Rc<T>`來說，它並不創建一個完整的拷貝。`Rc<T>`存放了**引用計數**，也就是說，一個存在多少個克隆的計數器。讓我們像列表 15-13 那樣在創建`c`時增加一個內部作用域，並在不同的位置打印出關聯函數`Rc::strong_count`的結果。`Rc::strong_count`返回傳遞給它的`Rc`值的引用計數，而在本章的稍後部分介紹避免引用循環時講到它為什麼叫做`strong_count`。

<span class="filename">Filename: src/main.rs</span>

```rust
# enum List {
#     Cons(i32, Rc<List>),
#     Nil,
# }
#
# use List::{Cons, Nil};
# use std::rc::Rc;
#
fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("rc = {}", Rc::strong_count(&a));
    let b = Cons(3, a.clone());
    println!("rc after creating b = {}", Rc::strong_count(&a));
    {
        let c = Cons(4, a.clone());
        println!("rc after creating c = {}", Rc::strong_count(&a));
    }
    println!("rc after c goes out of scope = {}", Rc::strong_count(&a));
}
```

<span class="caption">Listing 15-13: Printing out the reference count</span>

這會打印出：

```
rc = 1
rc after creating b = 2
rc after creating c = 3
rc after c goes out of scope = 2
```

不難看出`a`的初始引用計數是一。接著每次調用`clone`，計數會加一。當`c`離開作用域時，計數減一，這發生在`Rc<T>`的`Drop` trait 實現中。這個例子中不能看到的是當`b`接著是`a`在`main`函數的結尾離開作用域時，包含 5 和 10 的列表的引用計數會是 0，這時列表將被丟棄。這個策略允許擁有多個所有者，而引用計數會確保任何所有者存在時這個值保持有效。

在本部分的開始，我們說`Rc<T>`只允許程序的多個部分讀取`Rc<T>`中`T`的不可變引用。如果`Rc<T>`允許一個可變引用，我們將遇到第四章討論的借用規則所不允許的問題：兩個指向同一位置的可變借用會導致數據競爭和不一致。不過可變數據是非常有用的！在下一部分，我們將討論內部可變性模式和`RefCell<T>`類型，它可以與`Rc<T>`結合使用來處理不可變性的限制。