# 無畏並發

> [ch16-00-concurrency.md](https://github.com/rust-lang/book/blob/master/second-edition/src/ch16-00-concurrency.md)
> <br>
> commit da15de39eaabd50100d6fa662c653169254d9175

確保內存安全並不是 Rust 的唯一目標：更好的處理並發和並行編程一直是 Rust 的另一個主要目標。
**並發編程**（*concurrent programming*）代表程序的不同部分相互獨立的執行，而**並行編程**(*parallel programming*)代表程序不同部分同時執行，這兩個概念在計算機擁有更多處理器可供程序利用時變得更加重要。由於歷史的原因，在此類上下文中編程一直是困難且容易出錯的：Rust 希望能改變這一點。

最開始，我們認為內存安全和防止並發問題是需要通過兩個不同的方法解決的兩個相互獨立的挑戰。然而，隨著時間的推移，我們發現所有權和類型系統是一系列解決內存安全**和**並發問題的強用力的工具！通過改進所有權和類型檢查，很多並發錯誤在 Rust 中都是**編譯時**錯誤，而不是運行時錯誤。我們給 Rust 的這一面向起了一個綽號**無畏並發**（*fearless concurrency*）。無畏並發意味著 Rust 不光允許你自信代碼不會出現詭異的錯誤，也讓你可以輕易重構這種代碼而無需擔心會引入新的 bug。

> 注意：對於 Rust 的口號**無畏並發**，這裡用**並發**指代很多問題而不是更精確的區分**並發和（或）並行**，是出於簡化問題的原因。如果這是一本專注於並發和/或並行的書，我們肯定會更精確的。對於本章，當我們談到**並發**時，請自行替換為**並發和（或）並行**。

很多語言所提供的處理並發問題的解決方法都非常有特色，尤其是對於更高級的語言，這是一個非常合理的策略。然而對於底層語言則沒有奢侈的選擇。在任何給定的情況下，我們都期望底層語言可以提供最高的性能，並且對硬件有更薄的抽象。因此，Rust 給了我們多種工具，並以適合實際情況和需求的方式來為問題建模。

如下是本章將要涉及到的內容：

* 如何創建線程來同時運行多段代碼。
* 並發**消息傳遞**（*Message passing*），其中通道（channel）被用來在線程間傳遞消息。
* 並發**共享狀態**（*Shared state*），其中多個線程可以訪問同一片數據。
* `Sync`和`Send` trait，他們允許 Rust 的並發保證能被擴展到用戶定義的和標準庫中提供的類型中。