## 使用`Sync`和`Send` trait 的可擴展並發

> [ch16-04-extensible-concurrency-sync-and-send.md](https://github.com/rust-lang/book/blob/master/second-edition/src/ch16-04-extensible-concurrency-sync-and-send.md)
> <br>
> commit 9430a3d28a2121a938d704ce48b15d21062f880e

Rust 的並發模型中一個有趣的方面是：語言本身對並發知之**甚少**。我們之前討論的幾乎所有內容，都屬於標準庫，而不是語言本身的內容。由於不需要語言提供並發相關的基礎設施，並發方案不受標準庫或語言所限：我們可以編寫自己的或使用別人編寫的。

我們說「**幾乎**所有內容都不屬於語言本身」，那麼屬於語言本身的是什麼呢？是兩個 trait，都位於`std::marker`： `Sync`和`Send`。

### `Send`用於表明所有權可能被傳送給其他線程

`Send`標記 trait 表明類型的所有權可能被在線程間傳遞。幾乎所有的 Rust 類型都是`Send`的，不過有一些例外。比如標準庫中提供的 `Rc<T>`：如果克隆`Rc<T>`值，並嘗試將克隆的所有權傳遞給另一個線程，這兩個線程可能會同時更新引用計數。正如上一部分提到的，`Rc<T>`被實現為用於單線程場景，這時不需要為擁有線程安全的引用計數而付出性能代價。

因為 `Rc<T>` 沒有標記為 `Send`，Rust 的類型系統和 trait bound 會確保我們不會錯誤的把一個 `Rc<T>` 值不安全的在線程間傳遞。代碼例 16-14 曾嘗試這麼做，不過得到了一個錯誤，`the trait Send is not implemented for Rc<Mutex<i32>>`。而使用標記為 `Send` 的 `Arc<T>` 時，就沒有問題了。

任何完全由 `Send` 的類型組成的類型也會自動被標記為 `Send`：幾乎所有基本類型都是 `Send` 的，大部分標準庫類型是`Send`的，除了`Rc<T>`，以及第十九章將會討論的裸指針（raw pointer）。

### `Sync` 表明多線程訪問是安全的

`Sync` 標記 trait 表明一個類型可以安全的在多個線程中擁有其值的引用。換一種方式來說，對於任意類型 `T`，如果`&T`（`T`的引用）是`Send`的話`T`就是`Sync`的，這樣其引用就可以安全的發送到另一個線程。類似於 `Send` 的情況，基本類型是 `Sync` 的，完全由 `Sync` 的類型組成的類型也是 `Sync` 的。

`Rc<T>` 也不是 `Sync` 的，出於其不是`Send`的相同的原因。`RefCell<T>`（第十五章討論過）和`Cell<T>`系列類型不是`Sync`的。`RefCell<T>`在運行時所進行的借用檢查也不是線程安全的。`Mutex<T>`是`Sync`的，正如上一部分所講的它可以被用來在多線程中共享訪問。

### 手動實現`Send`和`Sync`是不安全的

通常並不需要實現`Send`和`Sync` trait，由屬於`Send`和`Sync`的類型組成的類型，自動就是`Send`和`Sync`的。因為他們是標記 trait，甚至都不需要實現任何方法。他們只是用來加強並發相關的不可變性的。

實現這些標記 trait 涉及到編寫不安全的 Rust 代碼，第十九章將會講述具體的方法；當前重要的是，在創建新的由不是`Send`和`Sync`的部分構成的並發類型時需要多加小心，以確保維持其安全保證。[The Nomicon] 中有更多關於這些保證以及如何維持他們的信息。

[The Nomicon]: https://doc.rust-lang.org/stable/nomicon/

## 總結

這不會是本書最後一個出現並發的章節；第二十章的項目會在更現實的場景中使用這些概念，而不像本章中討論的這些小例子。

正如我們提到的，因為 Rust 本身很少有處理並發的部分內容，有很多的並發方案都由 crate 實現。他們比標準庫要發展的更快；請在網上搜索當前最新的用於多線程場景的 crate。

Rust 提供了用於消息傳遞的通道，和像`Mutex<T>`和`Arc<T>`這樣可以安全的用於並發上下文的智能指針。類型系統和借用檢查器會確保這些場景中的代碼，不會出現數據競爭和無效的引用。一旦代碼可以編譯了，我們就可以堅信這些代碼可以正確的運行於多線程環境，而不會出現其他語言中經常出現的那些難以追蹤的 bug。並發編程不再是什麼可怕的概念：無所畏懼地並發吧！

接下來，讓我們討論一下當 Rust 程序變得更大時，有哪些符合語言習慣的問題建模方法和結構化解決方案，以及 Rust 的風格是如何與面向物件編程（Object Oriented Programming）中那些你所熟悉的概念相聯繫的。