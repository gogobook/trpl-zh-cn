## 字符串

> [ch08-02-strings.md](https://github.com/rust-lang/book/blob/master/second-edition/src/ch08-02-strings.md)
> <br>
> commit 692c4a78aac93670bc6f1fa5d33f71ed161b9339

第四章已經講過一些字符串的內容，不過現在讓我們更深入地瞭解它。字符串是新手 Rustacean 們通常會被困住的領域。這是由於三方面內容的結合：Rust 傾向於確保暴露出可能的錯誤，字符串是比很多程式設計師所想像的要更為複雜的數據結構，以及 UTF-8。所有這些結合起來對於來自其他語言背景的程式設計師就可能顯得很困難了。

字符串出現在集合章節的原因是，字符串是作為字節的集合外加一些方法實現的，當這些字節被解釋為文本時，這些方法提供了實用的功能。在這一部分，我們會講到 `String` 中那些任何集合類型都有的操作，比如創建、更新和讀取。也會討論 `String` 與其他集合不一樣的地方，例如索引` String` 是很複雜的，由於人和計算機理解 `String` 數據方式的不同。

### 什麼是字符串？

在開始深入這些方面之前，我們需要討論一下術語 **字符串** 的具體意義。Rust 的核心語言中事實上就只有一種字符串類型：`str`，字符串 slice，它通常以被借用的形式出現，`&str`。第四章講到了 **字符串 slice**：他們是一些儲存在別處的 UTF-8 編碼字符串數據的引用。比如字符串字面值被儲存在程序的二進制輸出中，字符串 slice 也是如此。

稱作 `String` 的類型是由標準庫提供的，而沒有寫進核心語言部分，它是可增長的、可變的、有所有權的、UTF-8 編碼的字符串類型。當 Rustacean 們談到 Rust 的 「字符串」時，他們通常指的是 `String` 和字符串 slice `&str`類型，而不是其中一個。這一部分大部分是關於 `String` 的，不過這些類型在 Rust 標準庫中都被廣泛使用。`String` 和字符串 slice 都是 UTF-8 編碼的。

Rust 標準庫中還包含一系列其他字符串類型，比如 `OsString`、`OsStr`、`CString` 和 `CStr`。相關庫 crate 甚至會提供更多儲存字符串數據的選擇。與 `*String`/`*Str` 的命名類似，他們通常也提供有所有權和可借用的變體，就比如說 `String`/`&str`。這些字符串類型在儲存的編碼或內存表現形式上可能有所不同。本章將不會討論其他這些字符串類型；查看 API 文檔來更多的瞭解如何使用他們以及各自適合的場景。

### 新建字符串

很多 `Vec` 可用的操作在 `String` 中同樣可用，從以 `new` 函數創建字符串開始，像這樣：

```rust
let mut s = String::new();
```

這新建了一個叫做 `s` 的空的字符串，接著我們可以向其中裝載數據。

通常字符串會有初始數據因為我們希望一開始就有這個字符串。為此，使用 `to_string` 方法，它能用於任何實現了 `Display` trait 的類型，對於字符串字面值是這樣：

```rust
let data = "initial contents";

let s = data.to_string();

// the method also works on a literal directly:
let s = "initial contents".to_string();
```

這會創建一個包含 `initial contents` 的字符串。

也可以使用 `String::from` 函數來從字符串字面值創建 `String`。如下等同於使用 `to_string`：

```rust
let s = String::from("initial contents");
```

因為字符串使用廣泛，這裡有很多不同的用於字符串的通用 API 可供選擇。他們有些可能顯得有些多餘，不過都有其用武之地！在這個例子中，`String::from` 和 `.to_string` 最終做了完全相同的工作，所以如何選擇就是風格問題了。

記住字符串是 UTF-8 編碼的，所以可以包含任何可以正確編碼的數據：

```rust
let hello = "السلام عليكم";
let hello = "Dobrý den";
let hello = "Hello";
let hello = "שָׁלוֹם";
let hello = "नमस्ते";
let hello = "こんにちは";
let hello = "안녕하세요";
let hello = "你好";
let hello = "Olá";
let hello = "Здравствуйте";
let hello = "Hola";
```

### 更新字符串

`String` 的大小可以增長其內容也可以改變，就像可以放入更多數據來改變 `Vec` 的內容一樣。另外，`String` 實現了 `+` 運算符作為級聯運算符以便於使用。

#### 使用 push 附加字符串

可以通過 `push_str` 方法來附加字符串 slice，從而使 `String` 變長：

```rust
let mut s = String::from("foo");
s.push_str("bar");
```

執行這兩行代碼之後 `s` 將會包含 「foobar」。`push_str` 方法抓取字符串 slice，因為並不需要抓取參數的所有權。例如，如果將 `s2` 的內容附加到 `s1` 中後自身不能被使用就糟糕了：

```rust
let mut s1 = String::from("foo");
let s2 = String::from("bar");
s1.push_str(&s2);
```

`push` 方法被定義為抓取一個單獨的字符作為參數，並附加到 `String` 中：

```rust
let mut s = String::from("lo");
s.push('l');
```

執行這些代碼之後，`s` 將會包含 「lol」。

#### 使用 + 運算符或 `format!` 巨集級聯字符串

通常我們希望將兩個已知的字符串合併在一起。一種辦法是像這樣使用 `+` 運算符：

```rust
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // Note that s1 has been moved here and can no longer be used
```

執行完這些代碼之後字符串 `s3` 將會包含 `Hello, world!`。`s1` 在相加後不再有效的原因，和使用 `s2` 的引用的原因與使用 `+` 運算符時調用的方法簽名有關，這個函數簽名看起來像這樣：

```rust
fn add(self, s: &str) -> String {
```

這並不是標準庫中實際的簽名；那個 `add` 使用泛型定義。這裡我們看到的 `add` 的簽名使用具體類型代替了泛型，這也正是當使用 `String` 值調用這個方法會發生的。第十章會討論泛型。這個簽名提供了理解 `+` 運算那奇怪的部分的線索。

首先，`s2` 使用了 `&`，意味著我們使用第二個字符串的 **引用** 與第一個字符串相加。這是因為 `add` 函數的 `s` 參數：只能將 `&str` 和 `String` 相加，不能將兩個 `String` 值相加。不過等一下——正如 `add` 的第二個參數所指定的，`&s2` 的類型是 `&String` 而不是 `&str`。那麼為什麼代碼還能編譯呢？之所以能夠在 `add` 調用中使用 `&s2` 是因為 `&String` 可以被**強轉**（*coerced*）成 `&str`——當`add`函數被調用時，Rust 使用了一個被稱為 **解引用強制多態**（*deref coercion*）的技術，你可以將其理解為它把 `&s2` 變成了 `&s2[..]` 以供 `add` 函數使用。第十五章會更深入的討論解引用強制多態。因為 `add` 沒有抓取參數的所有權，所以 `s2` 在這個操作後仍然是有效的 `String`。

其次，可以發現簽名中 `add` 抓取了 `self` 的所有權，因為 `self` **沒有** 使用 `&`。這意味著上面例子中的 `s1` 的所有權將被移動到 `add` 調用中，之後就不再有效。所以雖然 `let s3 = s1 + &s2;` 看起來就像它會複製兩個字符串並創建一個新的字符串，而實際上這個語句會抓取 `s1` 的所有權，附加上從 `s2` 中拷貝的內容，並返回結果的所有權。換句話說，它看起來好像生成了很多拷貝不過實際上並沒有：這個實現比拷貝要更高效。

如果想要級聯多個字符串，`+` 的行為就顯得笨重了：

```rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = s1 + "-" + &s2 + "-" + &s3;
```

這時 `s` 的內容會是 「tic-tac-toe」。在有這麼多 `+` 和 `"` 字符的情況下，很難理解具體發生了什麼。對於更為複雜的字符串鏈接，可以使用 `format!` 巨集：

```rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = format!("{}-{}-{}", s1, s2, s3);
```

這些代碼也會將 `s` 設置為 「tic-tac-toe」。`format!` 與 `println!` 的工作原理相同，不過不同於將輸出打印到屏幕上，它返回一個帶有結果的 `String`。這個版本就好理解的多，並且不會抓取任何參數的所有權。

### 索引字符串

在很多語言中，通過索引來引用字符串中的單獨字符是有效且常見的操作。然而在 Rust 中，如果我們嘗試使用索引語法訪問 `String` 的一部分，會出現一個錯誤。比如如下代碼：

```rust
let s1 = String::from("hello");
let h = s1[0];
```

會導致如下錯誤：

```text
error: the trait bound `std::string::String: std::ops::Index<_>` is not
satisfied [--explain E0277]
  |>
  |>     let h = s1[0];
  |>             ^^^^^
note: the type `std::string::String` cannot be indexed by `_`
```

錯誤和提示說明了全部問題：Rust 的字符串不支持索引。那麼接下來的問題是，為什麼不支持呢？為了回答這個問題，我們必須先聊一聊 Rust 是如何在內存中儲存字符串的。

#### 內部表示

`String` 是一個 `Vec<u8>` 的封裝。讓我們看看之前一些正確編碼的字符串的例子。首先是這一個：

```rust
let len = String::from("Hola").len();
```

在這裡，`len` 的值是四，這意味著儲存字符串 「Hola」 的 `Vec` 的長度是四個字節：每一個字符的 UTF-8 編碼都佔用一個字節。那下面這個例子又如何呢？

```rust
let len = String::from("Здравствуйте").len();
```

當問及這個字符是多長的時候有人可能會說是 12。然而，Rust 的回答是 24。這是使用 UTF-8 編碼 「Здравствуйте」 所需要的字節數，這是因為每個 Unicode 標量值需要兩個字節存儲。因此一個字符串字節值的索引並不總是對應一個有效的 Unicode 標量值。

作為演示，考慮如下無效的 Rust 代碼：

```rust
let hello = "Здравствуйте";
let answer = &hello[0];
```

`answer` 的值應該是什麼呢？它應該是第一個字符 `З` 嗎？當使用 UTF-8 編碼時，`З` 的第一個字節 `208`，第二個是 `151`，所以 `answer` 實際上應該是 `208`，不過 `208` 自身並不是一個有效的字母。返回 `208` 可不是一個請求字符串第一個字母的人所希望看到的，不過它是 Rust 在字節索引零位置所能提供的唯一數據。返回字節值可能不是人們希望看到的，即便是只有拉丁字母時：`&"hello"[0]` 會返回 `104` 而不是 `h`。為了避免返回意想不到值並造成不能立刻發現的 bug。Rust 選擇不編譯這些代碼並及早杜絕了誤會的發生。

#### 字節、標量值和字形簇！天吶！

這引起了關於 UTF-8 的另外一個問題：從 Rust 的角度來講，事實上有三種相關方式可以理解字符串：字節、標量值和字形簇（最接近人們眼中 **字母** 的概念）。

比如這個用梵文書寫的印度語單詞 「नमस्ते」，最終它儲存在 `Vec` 中的 `u8` 值看起來像這樣：

```text
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
```

這裡有 18 個字節，也就是計算機最終會儲存的數據。如果從 Unicode 標量值的角度理解他們，也就像 Rust 的 `char` 類型那樣，這些字節看起來像這樣：

```text
['न', 'म', 'स', '्', 'त', 'े']
```

這裡有六個 `char`，不過第四個和第六個都不是字母，他們是發音符號本身並沒有任何意義。最後，如果以字形簇的角度理解，就會得到人們所說的構成這個單詞的四個字母：

```text
["न", "म", "स्", "ते"]
```

Rust 提供了多種不同的方式來解釋計算機儲存的原始字符串數據，這樣程序就可以選擇它需要的表現方式，而無所謂是何種人類語言。

最後一個 Rust 不允許使用索引抓取 `String` 字符的原因是索引操作預期總是需要常數時間 (O(1))。但是對於 `String` 不可能保證這樣的性能，因為 Rust 不得不檢查從字符串的開頭到索引位置的內容來確定這裡有多少有效的字符。

### 字符串 slice

因為字符串索引應該返回的類型是不明確的，而且索引字符串通常也是一個壞點子，所以 Rust 不建議這麼做，而如果你確實需要它的話則需要更加明確一些。比使用 `[]` 和單個值的索引更加明確的方式是使用 `[]` 和一個 range 來創建包含特定字節的字符串 slice：

```rust
let hello = "Здравствуйте";

let s = &hello[0..4];
```

這裡，`s` 是一個 `&str`，它包含字符串的頭四個字節。早些時候，我們提到了這些字母都是兩個字節長的，所以這意味著 `s` 將會是 「Зд」。

如果抓取 `&hello[0..1]` 會發生什麼呢？答案是：在運行時會 panic，就跟訪問 vector 中的無效索引時一樣：

```text
thread 'main' panicked at 'index 0 and/or 1 in `Здравствуйте` do not lie on
character boundary', ../src/libcore/str/mod.rs:1694
```

你應該小心謹慎的使用這個操作，因為它可能會使你的程序崩潰。

### 遍歷字符串的方法

幸運的是，這裡還有其他抓取字符串元素的方式。

如果你需要操作單獨的 Unicode 標量值，最好的選擇是使用 `chars` 方法。對 「नमस्ते」 調用 `chars` 方法會將其分開並返回六個 `char` 類型的值，接著就可以遍歷結果來訪問每一個元素了：

```rust
for c in "नमस्ते".chars() {
    println!("{}", c);
}
```

這些代碼會打印出如下內容：

```text
न
म
स
्
त
े
```

`bytes` 方法返回每一個原始字節，這可能會適合你的使用場景：

```rust
for b in "नमस्ते".bytes() {
    println!("{}", b);
}
```

這些代碼會打印出組成 `String` 的 18 個字節，開頭是這樣的：

```text
224
164
168
224
// ... etc
```

不過請記住有效的 Unicode 標量值可能會由不止一個字節組成。

從字符串中抓取字形簇是很複雜的，所以標準庫並沒有提供這個功能。crates.io 上有些提供這樣功能的 crate。

### 字符串並不簡單

總而言之，字符串還是很複雜的。不同的語言選擇了不同的向程式設計師展示其複雜性的方式。Rust 選擇了以準確的方式處理 `String` 數據作為所有 Rust 程序的預設行為，這意味著程式設計師們必須更多的思考如何在前台處理 UTF-8 數據。這種權衡取捨相比其他語言更多的暴露出了字符串的複雜性，不過也使你在開發生命週期中免於處理涉及非 ASCII 字符的錯誤。

現在讓我們轉向一些不太複雜的集合：哈希 map！